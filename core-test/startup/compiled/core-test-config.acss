body:init {
	/* Note: window.testsRun gets used in Jasmine to report which tests have been run at the end, so it needs to be outside the Active CSS scope. */
	var: testIndex 0, window.testsRun [];

	/* Delay timings. Keep these here so it can be seen what's going on and adjusted if needed.
		Don't forget to adjust startup/core-test-settings.js if the overall time taken for the tests needs to change. The last number in the list is the guideline.
		Increment the tests by 250ms each time *if* field focus is required and you aren't writing a sequential test. Don't go less than that, just to be on the safe side.
	*/

	var: window.delayTimes {
		clickoutsideEvent: [1000, 1500],
		loadConfig: [5000]	/* This test must be run last, otherwise it can clash with delayed results. */
	};
	
	/* This has to go at the end if stuff goes above it :) */
	render: "<div id=\"content\"></div>";
}

.coreTest:draw {
	var: testIndex++;
	var: window.testsRun[testIndex] {};
	var: window.testsRun[testIndex].desc "{@data-desc}";
	trigger: test;
}

#content:draw {
	render-before-end: "<div id=\"checkCancelTimerAll\" data-desc=\"Basic cancel-timer-all command\" class=\"coreTest\">{|checkCancelTimerAllHTML}</div>";
}

@component checkCancelTimerAllHTML {
	html {
		<div id="cancelTimerAllDiv" style="background-color: blue;"></div>
	}
}

#checkCancelTimerAll:test {

	/* Cancel all by action test. */
	func: checkCancelTimerAllA;
	#cancelTimerAllDiv {
		background-color: green after 1s;
		add-class: .testAddition after 1s;
	}
	cancel-timer-all: true;
	func: checkCancelTimerAllB;

	/* Cancel all by label test. */
	#cancelTimerAllDiv {
		background-color: green after 1s label greenColor;
		add-class: .testAddition after 1s label myAddition;
		func: checkCancelTimerAllC;
	}
	cancel-timer-all: true;
	func: checkCancelTimerAllFinal;

}

#content:draw {
	render-before-end: "<div id=\"checkAddClass\" data-desc=\"Basic add-class command\" class=\"coreTest\"></div>";
}

#checkAddClass:test {
	add-class: .success;
}


#content:draw {
	render-before-end: "<div id=\"checkAjaxPreGet\" data-desc=\"Basic ajax-pre-get command\" class=\"coreTest\">{|checkAjaxPreGet}</div>";
}

@component checkAjaxPreGet {
	&:beforeComponentOpen {
		ajax-pre-get: "/base/core-test/tests/resource-files/ajax-pre-get-test-1.txt";
	}
	&:afterAjaxPreGet {
		func: checkAjaxPreGetA;
	}
	#checkAjaxPreGetTestTitle:draw {
		ajax: "/base/core-test/tests/resource-files/ajax-pre-get-test-1.txt" after 250ms;
	}
	&:afterAjax {
		func: checkAjaxPreGetFinal after 1s;	/* give component time to draw before checking */
	}
	html {
		<h2 id="checkAjaxPreGetTestTitle">{{checkAjaxPreGetTitle}}</h2>
		<p id="checkAjaxPreGetTestAddress">{{checkAjaxPreGetAddress}}</p>
	}
}

#checkAjaxPreGet:test {
	/* Nothing to see here - the test functions gets run from afterAjaxPreGet in the component. */
}

#content:draw {
	render-before-end: "<div id=\"checkAjax\" data-desc=\"Basic ajax command\" class=\"coreTest\">{|checkAjaxHTML}</div>";
}

@component checkAjaxHTML {
	&:beforeComponentOpen {
		ajax: "/base/core-test/tests/resource-files/ajax-test-1.txt";
	}
	&:afterAjax {
		func: checkAjax after 1s;	/* give component time to draw before checking */
	}
	html {
		<h2 id="checkAjaxTestTitle">{{checkAjaxTitle}}</h2>
		<p id="checkAjaxTestAddress">{{checkAjaxAddress}}</p>
	}
}

#checkAjax:test {
	/* Nothing to see here - the test function gets run from afterAjax in the component. */
}

#content:draw {
	render-before-end: "<div id=\"checkAlert\" data-desc=\"Basic alert command\" class=\"coreTest\"></div>";
}

#checkAlert:test {
	alert: "checkAlert";
}


#content:draw {
	render-before-end: "<div id=\"checkBlur\" data-desc=\"Basic blur command\" class=\"coreTest\">{|checkBlurHTML}</div>";
}

@component checkBlurHTML {
	html {
		<input id="blurField" type="text" value="This text field will get focus after one second, and then will blur - or focus-off - two seconds after that.">
	}
}

#checkBlur:test {
	#blurField {
	    focus-on: self;
		func: checkBlurA;
	    blur: true;
	}
	func: checkBlurFinal;
}


#content:draw {
	render-before-end: "<div id=\"checkCancelTimer\" data-desc=\"Basic cancel-timer command\" class=\"coreTest\">{|checkCancelTimerHTML}</div>";
}

@component checkCancelTimerHTML {
	html {
		<div id="cancelTimerDiv" style="background-color: blue;"></div>
	}
}

#checkCancelTimer:test {

	/* Cancel by action test. */
	func: checkCancelTimerA;
	#cancelTimerDiv {
		background-color: green after 1s;
		func: checkCancelTimerB;
		cancel-timer: background-color;
	}

	/* Cancel by label test. */
	#cancelTimerDiv {
		background-color: green after 1s label greenColor;
		func: checkCancelTimerC;
		cancel-timer: greenColor;
	}
	func: checkCancelTimerFinal;

}

#content:draw {
	render-before-end: "<div id=\"checkClickOnFirst\" data-desc=\"Basic click-on-first command\" class=\"coreTest\">{|checkClickOnFirstHTML}</div>";
}

@component checkClickOnFirstHTML {
	html {
		<div id="clickOnFirstDiv">
		    <a data-color="green" href="">Apples</a>
		    <a data-color="orange" href="">Oranges</a>
		    <a data-color="white" href="">Lychee</a>
		    <a data-color="yellow" href="">Bananas</a>
		    <a data-color="purple and green" href="">Grapes</a>
		</div>
		<p id="clickOnFirstP"></p>
	}
}

#clickOnFirstDiv a:click {
	#clickOnFirstP {
		render: "{@data-color}";
	}
}

#checkClickOnFirst:test {
	func: checkClickOnFirstA;
	click-on-first: #clickOnFirstDiv a;
	func: checkClickOnFirstFinal;
}

#content:draw {
	render-before-end: "<div id=\"checkClickOnLast\" data-desc=\"Basic click-on-last command\" class=\"coreTest\">{|checkClickOnLastHTML}</div>";
}

@component checkClickOnLastHTML {
	html {
		<div id="clickOnLastDiv">
		    <a data-color="green" href="">Apples</a>
		    <a data-color="orange" href="">Oranges</a>
		    <a data-color="white" href="">Lychee</a>
		    <a data-color="yellow" href="">Bananas</a>
		    <a data-color="purple and green" href="">Grapes</a>
		</div>
		<p id="clickOnLastP"></p>
	}
}

#clickOnLastDiv a:click {
	#clickOnLastP {
		render: "{@data-color}";
	}
}

#checkClickOnLast:test {
	func: checkClickOnLastA;
	click-on-last: #clickOnLastDiv a;
	func: checkClickOnLastFinal;
}

#content:draw {
	render-before-end: "<div id=\"checkClickOnNextCycle\" data-desc=\"Basic click-on-next-cycle command\" class=\"coreTest\">{|checkClickOnNextCycleHTML}</div>";
}

@component checkClickOnNextCycleHTML {
	html {
		<div id="clickOnNextCycleDiv">
		    <a data-color="green" href="">Apples</a>
		    <a data-color="orange" href="">Oranges</a>
		    <a id="clickOnNextCycleStart" data-color="white" href="">Lychee</a>
		    <a data-color="yellow" href="">Bananas</a>
		    <a data-color="purple and green" href="">Grapes</a>
		</div>
		<p id="clickOnNextCycleP"></p>
	}
}

#clickOnNextCycleDiv a:click {
	#clickOnNextCycleP {
		render: "{@data-color}";
	}
}

#checkClickOnNextCycle:test {
	func: checkClickOnNextCycleA;
	focus-on: #clickOnNextCycleStart;
	click-on-next-cycle: #clickOnNextCycleDiv a;
	func: checkClickOnNextCycleB;
	focus-on-next-cycle: #clickOnNextCycleDiv a;
	click-on-next-cycle: #clickOnNextCycleDiv a;
	func: checkClickOnNextCycleC;
	focus-on-next-cycle: #clickOnNextCycleDiv a;
	click-on-next-cycle: #clickOnNextCycleDiv a;
	func: checkClickOnNextCycleFinal;
}

#content:draw {
	render-before-end: "<div id=\"checkClickOnNext\" data-desc=\"Basic click-on-next command\" class=\"coreTest\">{|checkClickOnNextHTML}</div>";
}

@component checkClickOnNextHTML {
	html {
		<div id="clickOnNextDiv">
		    <a data-color="green" href="">Apples</a>
		    <a data-color="orange" href="">Oranges</a>
		    <a id="clickOnNextStart" data-color="white" href="">Lychee</a>
		    <a data-color="yellow" href="">Bananas</a>
		    <a data-color="purple and green" href="">Grapes</a>
		</div>
		<p id="clickOnNextP"></p>
	}
}

#clickOnNextDiv a:click {
	#clickOnNextP {
		render: "{@data-color}";
	}
}

#checkClickOnNext:test {
	func: checkClickOnNextA;
	focus-on: #clickOnNextStart;
	click-on-next: #clickOnNextDiv a;
	func: checkClickOnNextB;
	focus-on-next: #clickOnNextDiv a;
	click-on-next: #clickOnNextDiv a;
	func: checkClickOnNextC;
	focus-on-next: #clickOnNextDiv a;
	click-on-next: #clickOnNextDiv a;
	func: checkClickOnNextFinal;
}

#content:draw {
	render-before-end: "<div id=\"checkClickOnPreviousCycle\" data-desc=\"Basic click-on-previous-cycle command\" class=\"coreTest\">{|checkClickOnPreviousCycleHTML}</div>";
}

@component checkClickOnPreviousCycleHTML {
	html {
		<div id="clickOnPreviousCycleDiv">
		    <a data-color="green" href="">Apples</a>
		    <a data-color="orange" href="">Oranges</a>
		    <a id="clickOnPreviousCycleStart" data-color="white" href="">Lychee</a>
		    <a data-color="yellow" href="">Bananas</a>
		    <a data-color="purple and green" href="">Grapes</a>
		</div>
		<p id="clickOnPreviousCycleP"></p>
	}
}

#clickOnPreviousCycleDiv a:click {
	#clickOnPreviousCycleP {
		render: "{@data-color}";
	}
}

#checkClickOnPreviousCycle:test {
	func: checkClickOnPreviousCycleA;
	focus-on: #clickOnPreviousCycleStart;
	click-on-previous-cycle: #clickOnPreviousCycleDiv a;
	func: checkClickOnPreviousCycleB;
	focus-on-previous-cycle: #clickOnPreviousCycleDiv a;
	click-on-previous-cycle: #clickOnPreviousCycleDiv a;
	func: checkClickOnPreviousCycleC;
	focus-on-previous-cycle: #clickOnPreviousCycleDiv a;
	click-on-previous-cycle: #clickOnPreviousCycleDiv a;
	func: checkClickOnPreviousCycleFinal;
}

#content:draw {
	render-before-end: "<div id=\"checkClickOnPrevious\" data-desc=\"Basic click-on-previous command\" class=\"coreTest\">{|checkClickOnPreviousHTML}</div>";
}

@component checkClickOnPreviousHTML {
	html {
		<div id="clickOnPreviousDiv">
		    <a data-color="green" href="">Apples</a>
		    <a data-color="orange" href="">Oranges</a>
		    <a id="clickOnPreviousStart" data-color="white" href="">Lychee</a>
		    <a data-color="yellow" href="">Bananas</a>
		    <a data-color="purple and green" href="">Grapes</a>
		</div>
		<p id="clickOnPreviousP"></p>
	}
}

#clickOnPreviousDiv a:click {
	#clickOnPreviousP {
		render: "{@data-color}";
	}
}

#checkClickOnPrevious:test {
	func: checkClickOnPreviousA;
	focus-on: #clickOnPreviousStart;
	click-on-previous: #clickOnPreviousDiv a;
	func: checkClickOnPreviousB;
	focus-on-previous: #clickOnPreviousDiv a;
	click-on-previous: #clickOnPreviousDiv a;
	func: checkClickOnPreviousC;
	focus-on-previous: #clickOnPreviousDiv a;
	click-on-previous: #clickOnPreviousDiv a;
	func: checkClickOnPreviousFinal;
}

#content:draw {
	render-before-end: "<div id=\"checkClickoutsideEvent\" data-desc=\"Basic clickoutside-event command\" class=\"coreTest\">{|checkClickoutsideEventHTML}</div>";
}

@component checkClickoutsideEventHTML {
	html {
		<input type="input" id="clickoutsideStartInput" value="" />		
		<input type="input" id="clickoutsideTemporaryInput" value="" />		
		<input type="input" id="clickoutsideEndInput" value="" />		
	}
}

#checkClickoutsideEvent:test {
	focus-on: #clickoutsideStartInput after {window.delayTimes.clickoutsideEvent[0]}ms;
}

body:not(.clickoutside1) #clickoutsideStartInput:not(.clickoutside1):focus {
	clickoutside-event: true;
	#clickoutsideEndInput {
		trigger-real: click;
	}
}

body:not(.clickoutside1) #clickoutsideStartInput:clickoutside {
	clickoutside-event: false;
	body {
		add-class: .clickoutside1;
	}
	focus-on: #clickoutsideTemporaryInput, #clickoutsideStartInput after {window.delayTimes.clickoutsideEvent[1]}ms;
}

body.clickoutside1 #clickoutsideStartInput:focus {
	clickoutside-event: true continue;
	#clickoutsideEndInput {
		trigger-real: click;
	}
}

body.clickoutside1 #clickoutsideStartInput:clickoutside {
	clickoutside-event: false;
	body {
		add-class: .clickoutside2;
	}
}

#clickoutsideEndInput:click {
	/* This should only get called once at the end when "clickoutside: true continue" is set despite trigger-real happening twice. */
	func: checkClickoutsideEvent;
}

/* Pended until clone/restore-clone issue 36 has been resolved.

#content:draw {
	render-before-end: "<div id=\"checkClone\" data-desc=\"Basic clone command\" class=\"coreTest\">{|checkCloneHTML}</div>";
}

@component checkCloneHTML {
	html {
		<p class="cloneText"><span>This text is going to be cloned</span></p>
		<div id="restoreCloneInHere"><div id="restoreHere"></div></div>
	}
}

#checkClone:test {
	func: checkCloneBefore;
	clone: .cloneText;
	#restoreHere {
		restore-clone: .cloneText;
	}
	func: checkClone;
}
*/
#content:draw {
	render-before-end: "<div id=\"checkCreateCommand\" data-desc=\"Basic create-command command\" class=\"coreTest\">{|checkCreateCommandHTML}</div>";
}

@component checkCreateCommandHTML {
	@command create-command-blue {=
		targetSelector.style.backgroundColor = 'blue';
	=}
	html {
		<div id="checkCreateCommandDiv"></div>
	}
}

#checkCreateCommand:test {
	create-command: create-command-yellow {=
		targetSelector.style.color = 'yellow';
	=};
	#checkCreateCommandDiv {
		create-command-blue: true;
		create-command-yellow: true;
		create-command-height100: true;
	}
	func: checkCreateCommand;
}

@command create-command-height100 {=
	targetSelector.style.height = '100px';
=}

#content:draw {
	var: ccValIs10 10, ccValIs20 20;
	render-before-end: "<div id=\"checkCreateConditional\" data-desc=\"Basic create-conditional command\" class=\"coreTest\">{|checkCreateConditionalHTML}</div>";
}

@component checkCreateConditionalHTML {
	@command conditional cc-equals-20 {=
		return (conditionalValue == 20);
	=}
	html {
	}
}

#checkCreateConditional:cc-equals-10({ccValIs10}):not-cc-equals-10({ccValIs20}):test {
	trigger: nextTest after 250ms;
}

#checkCreateConditional:not-cc-equals-10({ccValIs10}):test {
	func: checkCreateConditionalFail;
}

#checkCreateConditional:not-cc-equals-20({ccValIs20}):test {
	func: checkCreateConditionalFail;
}

#checkCreateConditional:cc-equals-20({ccValIs20}):not-cc-equals-20({ccValIs10}):nextTest {
	func: checkCreateConditionalFinal;
}

@command conditional cc-equals-10 {=
	return (conditionalValue == 10);
=}

#content:draw {
	create-element: create-element-tag observe(cetaga cetagb);
	var: ceStringTest "stringtest",
		createElementConnectCallbackVar false,
		createElementDisconnectedCallbackVar false,
		createElementAttributeChangeVar false
	;
	render-before-end: "<div id=\"checkCreateElement\" data-desc=\"Basic create-element command\" class=\"coreTest\">{|checkCreateElementHTML}</div>";
}

@component checkCreateElementHTML {
	html {
		<div id="createElementTagsWrapper">
			<create-element-tag cetaga="test1" cetagb="test2">
				<div id="checkCreateElementDiv">{{@host:cetaga}} {{@host:cetagb}} {{ceStringTest}}</div>
			</create-element-tag>
			<create-element-tag id="createElementTagToRemove"></create-element-tag>
			<create-element-tag id="createElementAttrChange" cetaga="a value"></create-element-tag>
		</div>
	}
}

create-element-tag:connectedCallback {
	var: createElementConnectCallbackVar true;
}

#createElementTagToRemove:connectedCallback {
	remove: self;
}

#createElementAttrChange:connectedCallback {
	set-attribute: cetaga "cheesey wotsits";
}

#createElementAttrChange:attrChangeCetaga {
	var: createElementAttributeChangeVar true;
}

#createElementTagToRemove:disconnectedCallback {
	var: createElementDisconnectedCallbackVar true;
}

#checkCreateElementDiv:draw {
	func: checkCreateElement {createElementConnectCallbackVar} {createElementDisconnectedCallbackVar} {createElementAttributeChangeVar} after 1s;
}

#checkCreateElement:test {
}

#content:draw {
	render-before-end: "<div id=\"checkEval\" data-desc=\"Basic eval command\" class=\"coreTest\"></div>";
}

#checkEval:test {
	eval: {= window.evalResult = 1 + 1; =};
	func: checkEval;
}

#content:draw {
	render-before-end: "<div id=\"checkFocusOff\" data-desc=\"Basic focus-off command\" class=\"coreTest\">{|checkFocusOffHTML}</div>";
}

@component checkFocusOffHTML {
	html {
		<input id="focusOffField" type="text" value="This text field will get focus after one second, and then will blur - or focus-off - two seconds after that.">
	}
}

#checkFocusOff:test {
	#focusOffField {
	    focus-on: self;
	    func: checkFocusOffA;
	    focus-off: true;
	}
	func: checkFocusOffFinal;
}

#content:draw {
	render-before-end: "<div id=\"checkFocusOnFirst\" data-desc=\"Basic focus-on-first command\" class=\"coreTest\">{|checkFocusOnFirstHTML}</div>";
}

@component checkFocusOnFirstHTML {
	html {
		<form id="focusOnFirstForm">
		    <input id="focusOnFirstTarget" type="text" name="focus1" value="Cheryl">
		    <input type="text" name="focus2" value="Dave">
		    <input type="text" name="focus3" value="Bob">
		    <input type="text" name="focus4" value="Tracy">
		    <input type="text" name="focus4" value="Sharon">
		</form>
	}
}

#checkFocusOnFirst:test {
	func: checkFocusOnFirstA;
	focus-on-first: #focusOnFirstForm input;
	func: checkFocusOnFirstFinal;
}

#content:draw {
	render-before-end: "<div id=\"checkFocusOnLast\" data-desc=\"Basic focus-on-last command\" class=\"coreTest\">{|checkFocusOnLastHTML}</div>";
}

@component checkFocusOnLastHTML {
	html {
		<form id="focusOnLastForm">
		    <input type="text" name="focus1" value="Cheryl">
		    <input type="text" name="focus2" value="Dave">
		    <input type="text" name="focus3" value="Bob">
		    <input type="text" name="focus4" value="Tracy">
		    <input id="focusOnLastTarget" type="text" name="focus4" value="Sharon">
		</form>
	}
}

#checkFocusOnLast:test {
	func: checkFocusOnLastA;
	focus-on-last: #focusOnLastForm input;
	func: checkFocusOnLastFinal;
}


#content:draw {
	render-before-end: "<div id=\"checkFocusOnNextCycle\" data-desc=\"Basic focus-on-next-cycle command\" class=\"coreTest\">{|checkFocusOnNextCycleHTML}</div>";
}

@component checkFocusOnNextCycleHTML {
	html {
		<div class="focusOnNextCycleBlock">
		    <a id="focusOnNextCycleEnd" href="">Apples</a>
		    <a href="">Oranges</a>
		    <a href="">Pears</a>
		    <a id="focusOnNextCycleStart" href="">Bananas</a>
		    <a id="focusOnNextCycleSecond" href="">Grapes</a>
		</div>
	}
}

#checkFocusOnNextCycle:test {
	func: checkFocusOnNextCycleA;
	focus-on: #focusOnNextCycleStart;
	func: checkFocusOnNextCycleB;
	focus-on-next-cycle: .focusOnNextCycleBlock a;
	func: checkFocusOnNextCycleC;
 	focus-on-next-cycle: .focusOnNextCycleBlock a;
	func: checkFocusOnNextCycleFinal;
}

#content:draw {
	render-before-end: "<div id=\"checkFocusOnNext\" data-desc=\"Basic focus-on-next command\" class=\"coreTest\">{|checkFocusOnNextHTML}</div>";
}

@component checkFocusOnNextHTML {
	html {
		<div class="focusOnNextBlock">
		    <a href="">Apples</a>
		    <a href="">Oranges</a>
		    <a id="focusOnNextStart" href="">Pears</a>
		    <a id="focusOnNextSecond" href="">Bananas</a>
		    <a id="focusOnNextEnd" href="">Grapes</a>
		</div>
	}
}

#checkFocusOnNext:test {
	func: checkFocusOnNextA;
    focus-on: #focusOnNextStart;
	func: checkFocusOnNextB;
	focus-on-next: .focusOnNextBlock a;
	func: checkFocusOnNextC;
	focus-on-next: .focusOnNextBlock a;
	func: checkFocusOnNextD;
	focus-on-next: .focusOnNextBlock a;
	func: checkFocusOnNextFinal;
}

#content:draw {
	render-before-end: "<div id=\"checkFocusOnPreviousCycle\" data-desc=\"Basic focus-on-previous-cycle command\" class=\"coreTest\">{|checkFocusOnPreviousCycleHTML}</div>";
}

@component checkFocusOnPreviousCycleHTML {
	html {
		<div class="focusOnPreviousCycleBlock">
		    <a id="focusOnPreviousCycleSecond" href="">Apples</a>
		    <a id="focusOnPreviousCycleStart" href="">Oranges</a>
		    <a href="">Pears</a>
		    <a href="">Bananas</a>
		    <a id="focusOnPreviousCycleEnd" href="">Grapes</a>
		</div>
	}
}

#checkFocusOnPreviousCycle:test {
	func: checkFocusOnPreviousCycleA;
    focus-on: #focusOnPreviousCycleStart;
	func: checkFocusOnPreviousCycleB;
	focus-on-previous-cycle: .focusOnPreviousCycleBlock a;
	func: checkFocusOnPreviousCycleC;
	focus-on-previous-cycle: .focusOnPreviousCycleBlock a;
	func: checkFocusOnPreviousCycleFinal;
}

#content:draw {
	render-before-end: "<div id=\"checkFocusOnPrevious\" data-desc=\"Basic focus-on-previous command\" class=\"coreTest\">{|checkFocusOnPreviousHTML}</div>";
}

@component checkFocusOnPreviousHTML {
	html {
		<div class="focusOnPreviousBlock">
		    <a id="focusOnPreviousEnd" href="">Apples</a>
		    <a id="focusOnPreviousSecond" href="">Oranges</a>
		    <a id="focusOnPreviousStart" href="">Pears</a>
		    <a href="">Bananas</a>
		    <a href="">Grapes</a>
		</div>
	}
}

#checkFocusOnPrevious:test {
	func: checkFocusOnPreviousA;
	focus-on: #focusOnPreviousStart;
	func: checkFocusOnPreviousB;
	focus-on-previous: .focusOnPreviousBlock a;
	func: checkFocusOnPreviousC;
	focus-on-previous: .focusOnPreviousBlock a;
	func: checkFocusOnPreviousD;
	focus-on-previous: .focusOnPreviousBlock a;
	func: checkFocusOnPreviousFinal;
}

/* This is tested in the blur command test and will specifically error if it doesn't work. */

#content:draw {
	render-before-end: "<div id=\"checkFormReset\" data-desc=\"Basic form-reset command\" class=\"coreTest\">{|checkFormResetHTML}</div>";
}

@component checkFormResetHTML {
	html {
		<form id="checkFormForm">
		    <p><input id="checkFormRegularField" type="text" value="Bert"></p>
		    <p><input id="checkFormMimicField1" class="checkFormMimicClass" data-ref="1" type="text" placeholder="Mimic to A" value="Cheryl"></p>
		    <p>A: <span id="checkFormResultOfMimic1"></span></p>
		    <p><input id="checkFormMimicField2" class="checkFormMimicClass" data-ref="2" type="text" placeholder="Mimic to B" value="Bob"></p>
		    <p>B: <span id="checkFormResultOfMimic2"></span></p>
		    <p>Browser page title: <input id="checkFormPageTitle" type="text" value="cheeseyness" placeholder="Type here"></p>
		</form>
	}
}

#checkFormPageTitle: draw {
	/* Test browser page title mimic. */
	mimic-into: title;
}

.checkFormMimicClass:draw {
	/* Test mimic-into reset. Populate all the target fields when first drawn - this basically does the same thing as the input event. */
    mimic-into: #checkFormResultOfMimic{@data-ref};
}

#checkFormForm:draw {
	trigger: runTests after stack;
}

#checkFormForm:runTests {
	/* Force changes to the input fields and target fields - we don't have to test all field types as form-reset does an HTML form reset. */
	#checkFormRegularField, #checkFormMimicField1, #checkFormMimicField2 {
		set-property: value "changedResult";
	}
	#checkFormResultOfMimic1, #checkFormResultOfMimic2 {
		render: "changedResult";
	}
	document-title: "New page title";
	/* Check changed form values. */
	func: checkFormResetA;
	/* Reset the form. */
    form-reset: #checkFormForm;
	/* Check that the regular form field and mimic-into target fields have been reset to default values. */
	func: checkFormResetFinal;
}

#checkFormReset:test {
}

#content:draw {
	render-before-end: "<div id=\"checkFunc\" data-desc=\"Basic func command\" class=\"coreTest\"></div>";
}

#checkFunc:test {
	var: window.acSSGlobIt "some data";
	var: myACSSVariable {myObj: true, myArray: [1, 2, 3, 4]};
	func: checkFuncNum 8;
	func: checkFuncStr "test string";
	func: checkFuncTrue true;
	func: checkFuncFalse false;
/*	
	Still to set up:
	func: checkFuncArr [1, 2, "cheesey wotsit"];
	func: checkFuncObj {dave: "hi"};
	func: checkFuncWinVar window.globIt;
	func: checkFuncACSSVar {myACSSVariable};
	func: checkFuncExpr {= 7 + 10 =};
	func: checkFuncCombined [1, 2, "cheesey wotsit"] {dave: "hi"} window.globIt {myACSSVariable} {= new Date =};*/

	func: checkFuncFinal;
}

#content:draw {
	render-before-end: "<div id=\"checkIframeReload\" data-desc=\"Basic iframe-reload command\" class=\"coreTest\">{|checkIframeReloadHTML}</div>";
}

@component checkIframeReloadHTML {
	html {
		<iframe id="checkIframeIframe" srcdoc="<p>iframe test</p>"></iframe>
	}
}

#checkIframeReload:runTests {
	/* Check initial contents */
	func: checkIframeReloadA;
	/* Change the contents. */
	#checkIframeIframe -> p {
		render: "some new text";
	}
	/* Check for the new contents. */
	func: checkIframeReloadB;
	/* Re-load the iframe. */
	#checkIframeIframe {
		iframe-reload: true;
	}
	/* Check for the old contents. */
	func: checkIframeReloadFinal after 1s;
}

#checkIframeReload:test {
	trigger: runTests after 1s;
}

#content:draw {
	render-before-end: "<div id=\"checkLoadConfig\" data-desc=\"Basic load-config command\" class=\"coreTest\">{|checkLoadConfigHTML}</div>" after {window.delayTimes.loadConfig[0]}s;
}

@component checkLoadConfigHTML {
	&:componentOpen {
		/* In this case this needs to be in "open" and not "before open" otherwise the afterLoadConfig event cannot find the drawn div - ie. it hasn't been drawn yet. */
		/* The verification function is called from the load-config-test.acss config itself after it has been loaded. */
		load-config: "/base/core-test/tests/resource-files/load-config-test.acss";
	}
	html {
		<div></div>
	}
}

#checkLoadConfig:test {
}

#content:draw {
	render-before-end: "<div id=\"checkLoadImages\" data-desc=\"Basic load-images command\" class=\"coreTest\">{|checkLoadImagesHTML}</div>";
}

@component checkLoadImagesHTML {
	&:componentOpen {
		img[data-lazy-image], picture source[data-lazy-image] {
	        load-images: data-lazy-image;
	    }
    }
	html {
		<img id="checkLoadImagesImg1" src="/base/core-test/tests/resource-files/tiny.png" data-lazy-image="/base/core-test/tests/resource-files/cat3.gif" alt="">
		<picture>
		    <source id="checkLoadImagesPicSrc1" srcset="/base/core-test/tests/resource-files/tiny.png" data-lazy-image="/base/core-test/tests/resource-files/building-cliff-clouds-67235-tn.jpg" media="(min-width: 800px)">
		    <img id="checkLoadImagesImg2" src="/base/core-test/tests/resource-files/tiny.png" data-lazy-image="/base/core-test/tests/resource-files/cat2.gif" />
		</picture>
	}
}

#checkLoadImages:test {
	func: checkLoadImages after 1s;
}

#content:draw {
	render-before-end: "<div id=\"checkLoadScript\" data-desc=\"Basic load-script command\" class=\"coreTest\">{|checkLoadScriptHTML}</div>";
}

@component checkLoadScriptHTML {
	&:beforeComponentOpen {
		load-script: "/base/core-test/tests/resource-files/load-script-test.js";
	}
	&:afterLoadScript {
		func: checkLoadScript;
	}
	html {
		<div></div>
	}
}

#checkLoadScript:test {
}

#content:draw {
	render-before-end: "<div id=\"checkLoadStyle\" data-desc=\"Basic load-style command in document scope\" class=\"coreTest\">{|checkLoadStyleHTML}</div>";
	render-before-end: "<div id=\"checkLoadStyleShad\" data-desc=\"Basic load-style command in shadow scope\" class=\"coreTest\">{|checkLoadStyleHTMLShadow}</div>";
	render-before-end: "<div id=\"checkLoadStyleShad2\" data-desc=\"Basic load-style command in multiple shadow scopes\" class=\"coreTest\">{|checkLoadStyleHTMLShadow2}</div>";
}

@component checkLoadStyleHTML {
	&:componentOpen {
		load-style: "/base/core-test/tests/resource-files/load-style-test.css?v=123";
	}
	&:afterLoadStyle {
		func: checkLoadStyleDocument;
	}
	html {
		<div></div>
	}
}

@component checkLoadStyleHTMLShadow shadow {
	&:componentOpen {
		load-style: "/base/core-test/tests/resource-files/load-style-test-shadow.css";
	}
	&:afterLoadStyle {
		func: checkLoadStyleShadow;
	}
	html {
		<div></div>
	}
}

@component checkLoadStyleHTMLShadow2 shadow {
	&:componentOpen {
		load-style: "/base/core-test/tests/resource-files/load-style-test-shadow.css";
	}
	&:afterLoadStyle {
		func: checkLoadStyleShadow2;
	}
	html {
		<div></div>
	}
}

#checkLoadStyle:test {
}

#content:draw {
	render-before-end: "<div id=\"checkPreventDefault\" data-desc=\"Basic prevent-default command\" class=\"coreTest\">{|checkPreventDefaultHTML}</div>";
}

@component checkPreventDefaultHTML {
	a:click {
		prevent-default: true;
	}
	a:draw {
		trigger-real: click;
	}
	a:afterTriggerReal {
		func: checkPreventDefault;	/* If prevent-default works at all then passing the test in the function will be enough. */
	}
	html {
		<a href="/404.html">Test prevent default - this shouldn't do anything when clicked.</a>
	}
}

#checkPreventDefault:test {
}

#content:draw {
	render-before-end: "<div id=\"checkPreventDefaultShadow\" data-desc=\"Basic prevent-default in shadow command\" class=\"coreTest\">{|checkPreventDefaultHTMLShadow}</div>";
}

@component checkPreventDefaultHTML shadow {
	a:click {
		prevent-default: true;
	}
	a:draw {
		trigger-real: click;
	}
	a:afterTriggerReal {
		func: checkPreventDefaultShadow;	/* If prevent-default works at all then passing the test in the function will be enough. */
	}
	html {
		<a href="/404.html">Test prevent default - this shouldn't do anything when clicked.</a>
	}
}

#checkPreventDefaultShadow:test {
}

#content:draw {
	render-before-end: "<div id=\"checkRemoveAttribute\" data-desc=\"Basic remove-attribute command\" class=\"coreTest\">{|checkRemoveAttributeHTML}</div>";
}

@component checkRemoveAttributeHTML {
	html {
		<div id="removeAttributeDiv" data-test="some data"></div>
	}
}

#checkRemoveAttribute:test {
	#removeAttributeDiv {
		remove-attribute: data-test;
	}
	func: checkRemoveAttribute;
}

#content:draw {
	render-before-end: "<div id=\"checkRemoveClass\" data-desc=\"Basic remove-class command\" class=\"coreTest removeClassToRemove\"></div>";
}

#checkRemoveClass:test {
	remove-class: .removeClassToRemove;
	func: checkRemoveClass;
}

/* Pended until clone/restore-clone issue 36 has been resolved.
#content:draw {
	render-before-end: "<div id=\"checkRemoveClone\" data-desc=\"Basic remove-clone command\" class=\"coreTest\">{|checkRemoveCloneHTML}</div>";
}

@component checkRemoveCloneHTML {
	html {
	}
}

#checkRemoveClone:test {
	func: checkRemoveClone;
}
*/
#content:draw {
	render-before-end: "<div id=\"checkRemoveCookie\" data-desc=\"Basic remove-cookie command\" class=\"coreTest\"></div>";
}

#checkRemoveCookie:test {
	set-cookie: name("removeCookieTest1") value("Y") expires("1 Year") path("/") sameSite("Strict") secureIfHttps;
	func: checkRemoveCookieA;
	remove-cookie: name("removeCookieTest1") path("/");
	func: checkRemoveCookieFinal;
}

#content:draw {
	render-before-end: "<div id=\"checkRemoveProperty\" data-desc=\"Basic remove-property command\" class=\"coreTest\">{|checkRemovePropertyHTML}</div>";
}

@component checkRemovePropertyHTML {
	html {
		<div id="removePropertyDiv" style="background-color: green;"></div>
	}
}

#checkRemoveProperty:test {
	#removePropertyDiv {
		func: checkRemovePropertyBefore;
		remove-property: background-color;
	}
	func: checkRemoveProperty;
}

#content:draw {
	render-before-end: "<div id=\"checkRemove\" data-desc=\"Basic remove command\" class=\"coreTest\">{|checkRemoveHTML}</div>";
}

@component checkRemoveHTML {
	html {
		<div id="removeToRemove"></div>
	}
}

#checkRemove:test {
	func: checkRemoveBefore;
	remove: #removeToRemove;
	func: checkRemove;
}

#content:draw {
	render-before-end: "<div id=\"checkRenderAfterBegin\" data-desc=\"Basic render-after-begin command\" class=\"coreTest\">{|checkRenderAfterBeginHTML}</div>";
}

@component checkRenderAfterBeginHTML {
	&:componentOpen {
	    #renderAfterBeginHTMLDiv {
	        render-after-begin: "<span id=\"checkRenderAfterBeginTestDiv\">render-after-begin</span>";
			func: checkRenderAfterBegin;
	    }
	}
    html {
		<p id="renderAfterBeginHTMLDiv">Text will be inserted in relation to this element.</p>
    }
}

#content:draw {
	render-before-end: "<div id=\"checkRenderAfterEnd\" data-desc=\"Basic render-after-end command\" class=\"coreTest\">{|checkRenderAfterEndHTML}</div>";
}

@component checkRenderAfterEndHTML {
	&:componentOpen {
	    #renderAfterEndHTMLDiv {
	        render-after-end: "<span id=\"checkRenderAfterEndTestDiv\">render-after-end</span>";
			func: checkRenderAfterEnd;
	    }
	}
    html {
		<p id="renderAfterEndHTMLDiv">Text will be inserted in relation to this element.</p>
    }
}

#content:draw {
	render-before-end: "<div id=\"checkRenderBeforeBegin\" data-desc=\"Basic render-before-begin command\" class=\"coreTest\">{|checkRenderBeforeBeginHTML}</div>";
}

@component checkRenderBeforeBeginHTML {
	&:componentOpen {
	    #renderBeforeBeginHTMLDiv {
	        render-before-begin: "<span id=\"checkRenderBeforeBeginTestDiv\">render-before-begin</span>";
			func: checkRenderBeforeBegin;
	    }
	}
    html {
		<p id="renderBeforeBeginHTMLDiv">Text will be inserted in relation to this element.</p>
    }
}

#content:draw {
	render-before-end: "<div id=\"checkRenderBeforeEnd\" data-desc=\"Basic render-before-end command\" class=\"coreTest\">{|checkRenderBeforeEndHTML}</div>";
}

@component checkRenderBeforeEndHTML {
	&:componentOpen {
	    #renderBeforeEndHTMLDiv {
	        render-before-end: "<span id=\"checkRenderBeforeEndTestDiv\">render-before-end</span>";
			func: checkRenderBeforeEnd;
	    }
	}
    html {
		<p id="renderBeforeEndHTMLDiv">Text will be inserted in relation to this element.</p>
    }
}

#content:draw {
	render-before-end: "<div id=\"checkRenderReplace\" data-desc=\"Basic render-replace command\" class=\"coreTest\">{|checkRenderReplaceHTML}</div>";
}

@component checkRenderReplaceHTML {
	&:componentOpen {
	    #renderReplaceHTMLDiv {
	        render-replace: "<div id=\"checkRenderReplaceTestDiv\">render-replace</div><div>{$SELF}</div>";
			func: checkRenderReplace;
	    }
	}
    html {
		<div id="renderReplaceOuterDiv"><p id="renderReplaceHTMLDiv">Text will be inserted in relation to this element.</p></div>
    }
}

#content:draw {
    var: renderHackA "<script>createHavoc()</script>";
	render-before-end: "<div id=\"checkRender\" data-desc=\"Basic render command\" class=\"coreTest\">{|checkRenderHTML}</div>";
}

@component checkRenderHTML {
	&:beforeComponentOpen {
	    var: renderHackB "<script>doMoreHavoc()</script>";
	}
	&:componentOpen {
	    #renderHTMLExample {
	        render: "<span id=\"checkRenderTestDiv\"><strong>render</strong></span>";
			func: checkRender;
	    }
		#renderEscapePTag {
	        render-after-end: "<span id=\"checkRenderAttrSubHack\">{@data-hackA}</span>" after stack;
			func: checkRenderEscaping after 1s;
		}
	}
    html {
        <div class="renderHTMLWrap">
            <p id="renderHTMLExample">Text will be inserted in relation to this element. Note variables cannot contain HTML tags with render.</p>
            <p id="renderEscapePTag" data-hackA="{renderHackA}" data-hackB="{renderHackB}">Check for escaped variable: {renderHackA} {{renderHackB}}. You should see the tag here in text form.</p>
        </div>
    }
}

/* This test is covered by the clone command test, as they work together. */
#content:draw {
	render-before-end: "<div id=\"checkRun\" data-desc=\"Basic run command\" class=\"coreTest\"></div>";
}

#checkRun:test {
	run: {= window.runResult = 1 + 1; =};
	func: checkRun;
}

#content:draw {
	render-before-end: "<div id=\"checkScrollIntoView\" data-desc=\"Basic scroll-into-view command\" class=\"coreTest\">{|checkScrollIntoViewHTML}</div>";
}

@component checkScrollIntoViewHTML {
	&:componentOpen {
		func: checkScrollIntoViewA;
		#checkScrollIntoViewDiv {
			scroll-into-view: true;
		}
		func: checkScrollIntoViewFinal;
	}
	html {
		<div style="position: relative; height: 2000px;">
			<div id="checkScrollIntoViewDiv" style="position: absolute; bottom: 0; height: 50px; width: 50px"></div>
		<div>
	}
}

#checkScrollIntoView:test {
}

#content:draw {
	render-before-end: "<div id=\"checkScrollX\" data-desc=\"Basic scroll-x command\" class=\"coreTest\">{|checkScrollXHTML}</div>";
}

@component checkScrollXHTML {
	#scrollXBox:draw {
		trigger: scrollings after stack;
	}
	#scrollXBox:scrollings {
		scroll-x: right;
		func: checkScrollXRight;
		scroll-x: 415;
		func: checkScrollXHalfway;
		scroll-x: left;
		func: checkScrollXFinal;
	}
	html {
		<style>
		#scrollXBox {
			width: 200px;
			height: 200px;
			overflow-x: scroll;
		}

		#scrollXBoxInner {
			position: relative;
			width: 1000px;
		}
		</style>

		<div id="scrollXWrap">
			<div id="scrollXBox">
				<div id="scrollXBoxInner">
					<p style="position: absolute; left: 0;">Left text</p>
					<p style="position: absolute; left: 46%;">About half-way</p>
					<p style="position: absolute; right: 0;">Right text</p>
				</div>
			</div>
		</div>
	}
}

#checkScrollX:test {
}

#content:draw {
	render-before-end: "<div id=\"checkScrollY\" data-desc=\"Basic scroll-y command\" class=\"coreTest\">{|checkScrollYHTML}</div>";
}

@component checkScrollYHTML {
	#scrollYBox:draw {
		trigger: scrollings after stack;
	}
	#scrollYBox:scrollings {
		scroll-y: bottom;
		func: checkScrollYBottom;
		scroll-y: 415;
		func: checkScrollYHalfway;
		scroll-y: top;
		func: checkScrollYFinal;
	}
	html {
		<style>
		#scrollYBox {
			width: 200px;
			height: 200px;
			overflow-y: scroll;
		}

		#scrollYBoxInner {
			position: relative;
			height: 1000px;
		}
		</style>

		<div id="scrollYWrap">
			<div id="scrollYBox">
				<div id="scrollYBoxInner">
					<p style="position: absolute; top: 0;">Top text</p>
					<p style="position: absolute; top: 46%;">About half-way</p>
					<p style="position: absolute; bottom: 0;">Bottom text</p>
				</div>
			</div>
		</div>
	}
}

#checkScrollY:test {
}

#content:draw {
	render-before-end: "<div id=\"checkSetAttribute\" data-desc=\"Basic set-attribute command\" class=\"coreTest\">{|checkSetAttributeHTML}</div>";
}

@component checkSetAttributeHTML {
	html {
		<div id="setAttributeDiv"></div>
	}
}

#checkSetAttribute:test {
	#setAttributeDiv {
		set-attribute: data-test "some data";
	}
	func: checkSetAttribute;
}

#content:draw {
	render-before-end: "<div id=\"checkSetClass\" data-desc=\"Basic set-class command\" class=\"coreTest\">{|checkSetClassHTML}</div>";
}

@component checkSetClassHTML {
	html {
		<div id="setClassBox" class="some randomClasses in here"></div>
	}
}

#checkSetClass:test {
	#setClassBox {
		set-class: "classes with .quotes";
		func: checkSetClassA;
		set-class: .someclasses .without .thequotes;
		func: checkSetClassB;
		set-class: moreclasses with no dots;
		func: checkSetClassFinal;
	}
}

#content:draw {
	render-before-end: "<div id=\"checkSetCookie\" data-desc=\"Basic set-cookie command\" class=\"coreTest\"></div>";
}

#checkSetCookie:test {
	set-cookie: name("test1") value("Y") expires("1 Year") path("/") sameSite("Strict") secureIfHttps;
	set-cookie: name("test2") value("some info\"'") expires("3 months") path("/") sameSite("Strict") secureIfHttps;
	set-cookie: name("test3") value("fred") expires("-1 hour") path("/") sameSite("Strict") secureIfHttps;
	set-cookie: name("test4") value("expired cookie") expires("Fri, 16 Oct 2020 09:01:01 GMT") path("/") sameSite("Strict") secureIfHttps;
	set-cookie: name("test5") value("non-expired cookie") expires("Fri, 31 Dec 9999 09:01:01 GMT") path("/") sameSite("Strict") secureIfHttps;
	set-cookie: name("test6") value("expression expired") expires("{= new Date(new Date().setFullYear(new Date().getFullYear() - 1)).toUTCString() =}") path("/") sameSite("Strict") secureIfHttps;
	set-cookie: name("test7") value("expression not expired") expires("{= new Date(new Date().setFullYear(new Date().getFullYear() + 1)).toUTCString() =}") path("/") sameSite("Strict") secureIfHttps;
	func: checkSetCookie;
}

#content:draw {
	render-before-end: "<div id=\"checkSetProperty\" data-desc=\"Basic set-property command\" class=\"coreTest\">{|checkSetPropertyHTML}</div>";
}

@component checkSetPropertyHTML {
	html {
		<input id="setPropertyInput" name="setPropertyInput" disabled></div>
	}
}

#checkSetProperty:test {
	#setPropertyInput {
		func: checkSetPropertyBefore;
		set-property: disabled false;
	}
	func: checkSetProperty;
}

#content:draw {
	render-before-end: "<div id=\"checkStopEventPropagation\" data-desc=\"Basic stop-event-propagation command\" class=\"coreTest\">{|checkStopEventPropagationHTML}</div>";
}

@component checkStopEventPropagationHTML {
	&:beforeComponentOpen {
		var: checkStopEventPropagationVar 0, checkStopEventPropagationAdditionalVar 0;
	}
	#checkStopEventPropagationDiv:draw {
		trigger-real: click;
		func: checkStopEventPropagation {checkStopEventPropagationVar} {checkStopEventPropagationAdditionalVar} after 1s;
	}
	#checkStopEventPropagationDiv:click {
		var: checkStopEventPropagationVar 1;
		stop-event-propagation: true;
	}
	.checkStopEventPropagationRunToo:click {
		/* This should get called also, as it's in the same element as the first click. */
		var: checkStopEventPropagationAdditionalVar 1;
	}
	#checkStopEventPropagationWrapper:click {
		/* This should not get called - if this is called then the event bubbled, which is not what we want here. */
		var: checkStopEventPropagationVar 10;
	}
	html {
		<div id="checkStopEventPropagationWrapper">
			<div id="checkStopEventPropagationDiv" class="checkStopEventPropagationRunToo"></div>
		</div>
	}
}

#checkStopEventPropagation:test {
}

#content:draw {
	render-before-end: "<div id=\"checkStopImmediateEventPropagation\" data-desc=\"Basic stop-immediate-event-propagation command\" class=\"coreTest\">{|checkStopImmediateEventPropagationHTML}</div>";
}

@component checkStopImmediateEventPropagationHTML {
	&:beforeComponentOpen {
		var: checkStopImmedEvPropFail false;
	}
	&:componentOpen {
		#checkStopImmedPropA {
			/* Don't run any more target selectors after this. */
			stop-immediate-event-propagation: true;

			/* after stack is important here, as we want to know the class event didn't run. */
			func: checkStopImmediateEventPropagation {checkStopImmedEvPropFail} after stack;
		}
		.checkStopImmedPropClass {
			var: checkStopImmedEvPropFail true;
		}
	}
	html {
		<div id="checkStopImmedPropA" class="checkStopImmedPropClass"></div>
		<div class="checkStopImmedPropClass"></div>
	}
}

#checkStopImmediateEventPropagation:test {
}

#content:draw {
	render-before-end: "<div id=\"checkStopImmediatePropagation\" data-desc=\"Basic stop-immediate-propagation command\" class=\"coreTest\">{|checkStopImmediatePropagationHTML}</div>";
}

@component checkStopImmediatePropagationHTML {
	&:beforeComponentOpen {
		var: checkStopImmedPropFail false;
	}
	&:componentOpen {
		#checkStopImmedPropA {
			/* Don't run any more target selectors after this. */
			stop-immediate-propagation: true;

			/* after stack is important here, as we want to know the class event didn't run. */
			func: checkStopImmediatePropagation {checkStopImmedPropFail} after 1s;
		}
		.checkStopImmedPropClass {
			var: checkStopImmedPropFail true;
		}
	}
	html {
		<div id="checkStopImmedPropA" class="checkStopImmedPropClass"></div>
		<div class="checkStopImmedPropClass"></div>
	}
}
#checkStopImmediatePropagation:test {
}

#content:draw {
	render-before-end: "<div id=\"checkStopPropagation\" data-desc=\"Basic stop-propagation command\" class=\"coreTest\">{|checkStopPropagationHTML}</div>";
}

@component checkStopPropagationHTML {
	&:beforeComponentOpen {
		var: checkStopPropagationVar 0, checkStopPropagationAdditionalVar 0;
	}
	#checkStopPropagationDiv:draw {
		trigger-real: click;
		func: checkStopPropagation {checkStopPropagationVar} {checkStopPropagationAdditionalVar} after 1s;
	}
	#checkStopPropagationDiv:click {
		var: checkStopPropagationVar 1;
		stop-propagation: true;
	}
	.checkStopPropagationRunToo:click {
		/* This should get called also, as it's in the same element as the first click. */
		var: checkStopPropagationAdditionalVar 1;
	}
	#checkStopPropagationWrapper:click {
		/* This should not get called - if this is called then the event bubbled, which is not what we want here. */
		var: checkStopPropagationVar 10;
	}
	html {
		<div id="checkStopPropagationWrapper">
			<div id="checkStopPropagationDiv" class="checkStopPropagationRunToo"></div>
		</div>
	}
}

#checkStopPropagation:test {
}

#content:draw {
	render-before-end: "<div id=\"checkStyle\" data-desc=\"Basic style command\" class=\"coreTest\"></div>";
}

#checkStyle:test {
	style: background-color green;
	func: checkStyle;
}

#content:draw {
	render-before-end: "<div id=\"checkTakeClass\" data-desc=\"Basic take-class command\" class=\"coreTest\">{|checkTakeClassHTML}</div>";
}

@component checkTakeClassHTML {
	html {
		<p>Click on a fruit to select it.</p>

		<div id="takeClassApple" class="takeClassFruit">Apple</div>
		<div id="takeClassOrange" class="takeClassFruit">Orange</div>
		<div id="takeClassLemon" class="takeClassFruit taken">Lemon</div>
		<div id="takeClassLime" class="takeClassFruit">Lime</div>
	}
}

#checkTakeClass:test {
	#takeClassOrange {
		take-class: .taken;
		func: checkTakeClassA;
	}
	#takeClassLime {
		take-class: .taken;
		func: checkTakeClassFinal;
	}
}

#content:draw {
	render-before-end: "<div id=\"checkToggleClass\" data-desc=\"Basic toggle-class command\" class=\"coreTest\">{|checkToggleClassHTML}</div>";
}

@component checkToggleClassHTML {
	html {
		<div id="toggleClassBox" class="exampleSquare"></div>
	}
}

#checkToggleClass:test {
	#toggleClassBox {
        toggle-class: .butNotReally;
		func: checkToggleClassA;
        toggle-class: .butNotReally;
		func: checkToggleClassFinal;
    }
}

#content:draw {
	render-before-end: "<div id=\"checkTriggerReal\" data-desc=\"Basic trigger-real command\" class=\"coreTest\">{|checkTriggerRealHTML}</div>";
}

@component checkTriggerRealHTML {
	p:draw {
		func: checkTriggerRealSetUpDocumentEvent;
		trigger-real: click;
	}
	p:click {
		render: "Hello. Is it me you're looking for too?";
	}
	html {
		<p></p>
	}
}

#checkTriggerReal:test {
	/* The test get runs from a document click event to test that it is true click event and not just a call to a Active CSS config event. */
}

#content:draw {
	render-before-end: "<div id=\"checkTrigger\" data-desc=\"Basic trigger command\" class=\"coreTest\">{|checkTriggerHTML}</div>";
}

@component checkTriggerHTML {
	p:draw {
		trigger: renderSomething;
	}
	p:renderSomething {
		render: "Hello. Is it me you're looking for?";
		func: checkTrigger;
	}
	html {
		<p></p>
	}
}

#checkTrigger:test {
}

#content:draw {
	render-before-end: "<div id=\"checkUrlChange\" data-desc=\"Basic url-change command\" class=\"coreTest\"></div>";
}

#checkUrlChange:test {
	url-change: "/test/funky/url" "Funky test URL";
	func: checkUrlChange;
}

#content:draw {
	render-before-end: "<div id=\"checkVar\" data-desc=\"Basic var command\" class=\"coreTest\">{|checkVarHTML}</div>";
}

@component checkVarHTML {
	&:componentOpen {
		var: varTestString "Hi, \"dude\".",
			varTestBooleanTrue true,
			varTestBooleanFalse false,
			varTestBooleanDigitPositive 10,
			varTestBooleanDigitNegative -20,
			varTestEvaluatedNumber 1 * 2 + 6,
			window.varTestWinVar "hello"	/* not yet supported - leave this here for the moment - an issue has been created for it. */
		;
		func: checkVar "{varTestString}"
			{varTestBooleanTrue}
			{varTestBooleanFalse}
			{varTestBooleanDigitPositive}
			{varTestBooleanDigitNegative}
			{varTestEvaluatedNumber}
			"{window.varTestWinVar}"	/* not yet supported - leave this here for the moment - an issue has been created for it. */
		;
	}
	html {
		<div>{|checkVarPrivateHTML}</div>
	}
}
